/**
 * Init command - bootstrap lint-staged configuration.
 *
 * @internal
 */
import { dirname } from "node:path";
import { Command, Options } from "@effect/cli";
import { FileSystem } from "@effect/platform";
import { Effect } from "effect";

/** Unicode checkmark symbol. */
const CHECK_MARK = "\u2713";

/** Unicode warning symbol. */
const WARNING = "\u26A0";

/** Executable file permission mode. */
const EXECUTABLE_MODE = 0o755;

/** Path for the husky pre-commit hook. */
const HUSKY_HOOK_PATH = ".husky/pre-commit";

/** Default path for the lint-staged config file. */
const DEFAULT_CONFIG_PATH = "lib/configs/lint-staged.config.ts";

/** Begin marker for managed section. */
const BEGIN_MARKER = "# --- BEGIN SAVVY-LINT MANAGED SECTION ---";

/** End marker for managed section. */
const END_MARKER = "# --- END SAVVY-LINT MANAGED SECTION ---";

/**
 * Generate the managed section content for the pre-commit hook.
 *
 * @param configPath - Path to the lint-staged config file
 * @returns The managed section content (without markers)
 */
function generateManagedContent(configPath: string): string {
	return `# DO NOT EDIT between these markers - managed by savvy-lint
# Skip in CI environment
{ [ -n "$CI" ] || [ -n "$GITHUB_ACTIONS" ]; } && exit 0

# Get repo root directory
ROOT=$(git rev-parse --show-toplevel)

# Detect package manager from package.json or lockfiles
detect_pm() {
  # Check packageManager field in package.json (e.g., "pnpm@9.0.0")
  if [ -f "$ROOT/package.json" ]; then
    pm=$(jq -r '.packageManager // empty' "$ROOT/package.json" 2>/dev/null | cut -d'@' -f1)
    if [ -n "$pm" ]; then
      echo "$pm"
      return
    fi
  fi

  # Fallback to lockfile detection
  if [ -f "$ROOT/pnpm-lock.yaml" ]; then
    echo "pnpm"
  elif [ -f "$ROOT/yarn.lock" ]; then
    echo "yarn"
  elif [ -f "$ROOT/bun.lock" ]; then
    echo "bun"
  else
    echo "npm"
  fi
}

# Get the exec command for the detected package manager
PM=$(detect_pm)
case "$PM" in
  pnpm) CMD="pnpm exec" ;;
  yarn) CMD="yarn exec" ;;
  bun)  CMD="bunx" ;;
  *)    CMD="npx --no --" ;;
esac

$CMD lint-staged --config "$ROOT/${configPath}"`;
}

/**
 * Generate the full husky pre-commit hook content for a fresh file.
 *
 * @param configPath - Path to the lint-staged config file
 * @returns Complete shell script content for the hook
 */
function generateFullHookContent(configPath: string): string {
	return `#!/usr/bin/env sh
# Pre-commit hook with savvy-lint managed section
# Custom hooks can go above or below the managed section

${BEGIN_MARKER}
${generateManagedContent(configPath)}
${END_MARKER}
`;
}

/**
 * Extract the managed section from existing hook content.
 *
 * @param content - The existing hook file content
 * @returns Object with beforeSection, managedSection, afterSection, and found flag
 */
function extractManagedSection(content: string): {
	beforeSection: string;
	managedSection: string;
	afterSection: string;
	found: boolean;
} {
	const beginIndex = content.indexOf(BEGIN_MARKER);
	const endIndex = content.indexOf(END_MARKER);

	if (beginIndex === -1 || endIndex === -1 || endIndex <= beginIndex) {
		return {
			beforeSection: content,
			managedSection: "",
			afterSection: "",
			found: false,
		};
	}

	return {
		beforeSection: content.slice(0, beginIndex),
		managedSection: content.slice(beginIndex, endIndex + END_MARKER.length),
		afterSection: content.slice(endIndex + END_MARKER.length),
		found: true,
	};
}

/**
 * Update existing hook content with new managed section.
 *
 * @param existingContent - The existing hook file content
 * @param configPath - Path to the lint-staged config file
 * @returns Updated hook content
 */
function updateManagedSection(existingContent: string, configPath: string): string {
	const { beforeSection, afterSection, found } = extractManagedSection(existingContent);

	const newManagedSection = `${BEGIN_MARKER}\n${generateManagedContent(configPath)}\n${END_MARKER}`;

	if (found) {
		// Replace existing managed section
		return `${beforeSection}${newManagedSection}${afterSection}`;
	}

	// No existing managed section - append at end
	const trimmedContent = existingContent.trimEnd();
	return `${trimmedContent}\n\n${newManagedSection}\n`;
}

/** Available presets. */
type PresetType = "minimal" | "standard" | "full";

/**
 * Generate the lint-staged config file content.
 *
 * @param preset - The preset to use
 * @returns Config file content
 */
function generateConfigContent(preset: PresetType): string {
	return `/**
 * lint-staged configuration
 * Generated by savvy-lint init
 */
import type { Configuration } from "lint-staged";
import { Preset } from "@savvy-web/lint-staged";

export default Preset.${preset}() satisfies Configuration;
`;
}

const forceOption = Options.boolean("force").pipe(
	Options.withAlias("f"),
	Options.withDescription("Overwrite entire hook file (not just managed section)"),
	Options.withDefault(false),
);

const configOption = Options.text("config").pipe(
	Options.withAlias("c"),
	Options.withDescription("Relative path for the lint-staged config file (from repo root)"),
	Options.withDefault(DEFAULT_CONFIG_PATH),
);

const presetOption = Options.choice("preset", ["minimal", "standard", "full"]).pipe(
	Options.withAlias("p"),
	Options.withDescription("Preset to use: minimal, standard, or full"),
	Options.withDefault("full" as const),
);

/**
 * Make a file executable.
 *
 * @param path - File path to make executable
 * @returns Effect that makes the file executable
 */
function makeExecutable(path: string) {
	return Effect.tryPromise(() => import("node:fs/promises").then((fs) => fs.chmod(path, EXECUTABLE_MODE)));
}

/**
 * Init command implementation.
 *
 * @remarks
 * Creates the necessary configuration files for lint-staged:
 * - `.husky/pre-commit` hook with managed section
 * - lint-staged config at the specified path
 *
 * The managed section feature allows users to add custom hooks above/below
 * the savvy-lint section without them being overwritten on updates.
 */
export const initCommand = Command.make(
	"init",
	{ force: forceOption, config: configOption, preset: presetOption },
	({ force, config, preset }) =>
		Effect.gen(function* () {
			const fs = yield* FileSystem.FileSystem;

			if (config.startsWith("/")) {
				yield* Effect.fail(new Error("Config path must be relative to repository root, not absolute"));
			}

			yield* Effect.log("Initializing lint-staged configuration...\n");

			// Handle husky hook
			const huskyExists = yield* fs.exists(HUSKY_HOOK_PATH);

			if (huskyExists && !force) {
				// Read existing content and update managed section
				const existingContent = yield* fs.readFileString(HUSKY_HOOK_PATH);
				const { found } = extractManagedSection(existingContent);

				const updatedContent = updateManagedSection(existingContent, config);
				yield* fs.writeFileString(HUSKY_HOOK_PATH, updatedContent);
				yield* makeExecutable(HUSKY_HOOK_PATH);

				if (found) {
					yield* Effect.log(`${CHECK_MARK} Updated managed section in ${HUSKY_HOOK_PATH}`);
				} else {
					yield* Effect.log(`${CHECK_MARK} Added managed section to ${HUSKY_HOOK_PATH}`);
				}
			} else if (huskyExists && force) {
				// Force: overwrite entire file
				yield* fs.writeFileString(HUSKY_HOOK_PATH, generateFullHookContent(config));
				yield* makeExecutable(HUSKY_HOOK_PATH);
				yield* Effect.log(`${CHECK_MARK} Replaced ${HUSKY_HOOK_PATH} (--force)`);
			} else {
				// Create new hook
				yield* fs.makeDirectory(".husky", { recursive: true });
				yield* fs.writeFileString(HUSKY_HOOK_PATH, generateFullHookContent(config));
				yield* makeExecutable(HUSKY_HOOK_PATH);
				yield* Effect.log(`${CHECK_MARK} Created ${HUSKY_HOOK_PATH}`);
			}

			// Handle config file
			const configExists = yield* fs.exists(config);

			if (configExists && !force) {
				yield* Effect.log(`${WARNING} ${config} already exists (use --force to overwrite)`);
			} else {
				const configDir = dirname(config);
				if (configDir && configDir !== ".") {
					yield* fs.makeDirectory(configDir, { recursive: true });
				}
				yield* fs.writeFileString(config, generateConfigContent(preset));
				yield* Effect.log(`${CHECK_MARK} Created ${config} (preset: ${preset})`);
			}

			yield* Effect.log("\nDone! Lint-staged is ready to use.");
		}),
).pipe(Command.withDescription("Initialize lint-staged configuration and husky hooks"));

export { BEGIN_MARKER, END_MARKER, extractManagedSection, generateManagedContent };
